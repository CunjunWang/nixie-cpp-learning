# C++的堆栈

```
int a = 0;                      // GVAR 全局初始化区
int* p1;                        // bss 全局未初始化区

int main() {                    // text 代码区
    int b;                      // stack栈区变量
    char s[] = "abc";           // stack栈区变量
    int* p2;                    // stack栈区变量
    char* p3 = "123456";        // 123456在常量区, p3在栈区
    static int c = 0;           // GVAR全局静态初始化区
    p1 = new int(10);           // heap堆区变量
    p2 = new int(20);           // heap堆区变量

    return 0;                   // text代码区
}
```

## C++中的程序存储
<img src="images/存储.png" alt="存储" width="500">

## C++中的动态分配原则
堆 Heap
1. 动态内存带来了不确定性: 内存分配耗时需要多久? 失败了怎么办?
2. 一般而言, 在堆上分配内存时, 很多语言会使用`new`这样的关键字,
有些语言则是隐式分配. 在C++中`new`的对应词是`delete`, 因为C++是
让程序员完全接管内存的分配和释放的

程序通常需要牵扯到三个内存管理的操作:
1. 分配一个某个大小的内存块
2. 释放一个之前分配的内存块
3. 垃圾收集操作, 寻找不再使用的内存块并予以释放
    - 回收策略需要实现性能、实时性、额外开销等各方面的平衡, 很难有统一和高效的做法

C++做了1和2, Java做了1和3
